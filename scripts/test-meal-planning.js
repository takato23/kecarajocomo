#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

/**
 * Comprehensive Meal Planning Test Runner
 * 
 * This script runs all meal planning tests with proper configuration,
 * generates coverage reports, and provides detailed feedback.
 */

const COLORS = {
  RESET: '\x1b[0m',
  BOLD: '\x1b[1m',
  RED: '\x1b[31m',
  GREEN: '\x1b[32m',
  YELLOW: '\x1b[33m',
  BLUE: '\x1b[34m',
  MAGENTA: '\x1b[35m',
  CYAN: '\x1b[36m',
};

const log = (message, color = COLORS.RESET) => {
  console.log(`${color}${message}${COLORS.RESET}`);
};

const runCommand = (command, description) => {
  log(`\n${COLORS.BLUE}▶ ${description}${COLORS.RESET}`);
  log(`${COLORS.CYAN}Command: ${command}${COLORS.RESET}`);
  
  try {
    const output = execSync(command, { 
      stdio: 'inherit',
      cwd: process.cwd(),
      env: { ...process.env, NODE_ENV: 'test' }
    });
    log(`${COLORS.GREEN}✓ ${description} completed successfully${COLORS.RESET}`);
    return true;
  } catch (error) {
    log(`${COLORS.RED}✗ ${description} failed${COLORS.RESET}`);
    console.error(error.message);
    return false;
  }
};

const checkFileExists = (filePath) => {
  return fs.existsSync(path.resolve(filePath));
};

const createCoverageDirectory = () => {
  const coverageDir = 'coverage/meal-planning';
  if (!fs.existsSync(coverageDir)) {
    fs.mkdirSync(coverageDir, { recursive: true });
    log(`${COLORS.YELLOW}Created coverage directory: ${coverageDir}${COLORS.RESET}`);
  }
};

const generateTestReport = (results) => {
  const reportPath = 'meal-planner-test-report.md';
  const timestamp = new Date().toISOString();
  
  const report = `# Meal Planner Test Report

**Generated:** ${timestamp}

## Test Results Summary

| Test Suite | Status | Duration |
|------------|--------|----------|
${results.map(r => `| ${r.name} | ${r.success ? '✅ PASS' : '❌ FAIL'} | ${r.duration || 'N/A'} |`).join('\n')}

## Coverage Summary

Run the following command to view detailed coverage:
\`\`\`bash
npm run test:meal-planning:coverage
\`\`\`

## Test Categories

### Unit Tests
- Component rendering and behavior
- Store state management
- Hook functionality
- Utility functions

### Integration Tests
- Component interaction flows
- API endpoint communication
- Database operations
- Real-time synchronization

### End-to-End Tests
- Complete user workflows
- Cross-browser compatibility
- Performance benchmarks
- Offline functionality

## Failed Tests

${results.filter(r => !r.success).map(r => `
### ${r.name}
- **Error:** ${r.error || 'Unknown error'}
- **Command:** \`${r.command}\`
`).join('\n')}

## Next Steps

1. Fix any failing tests
2. Review coverage reports
3. Add tests for uncovered edge cases
4. Update documentation if needed

---
*Generated by meal-planning test runner*
`;

  fs.writeFileSync(reportPath, report);
  log(`${COLORS.GREEN}Test report generated: ${reportPath}${COLORS.RESET}`);
};

const main = async () => {
  log(`${COLORS.BOLD}${COLORS.MAGENTA}🧪 Meal Planning Test Suite Runner${COLORS.RESET}`);
  log(`${COLORS.CYAN}Running comprehensive tests for meal planning feature...${COLORS.RESET}\n`);

  // Check prerequisites
  const requiredFiles = [
    'jest.config.meal-planning.js',
    'jest.setup.js',
    'package.json',
  ];

  for (const file of requiredFiles) {
    if (!checkFileExists(file)) {
      log(`${COLORS.RED}✗ Required file missing: ${file}${COLORS.RESET}`);
      process.exit(1);
    }
  }

  createCoverageDirectory();

  const testResults = [];
  const startTime = Date.now();

  // Parse command line arguments
  const args = process.argv.slice(2);
  const watchMode = args.includes('--watch');
  const coverageMode = args.includes('--coverage');
  const verboseMode = args.includes('--verbose');
  const e2eMode = args.includes('--e2e');
  const quickMode = args.includes('--quick');
  const updateSnapshots = args.includes('--updateSnapshot');

  // Test configurations
  const testConfigs = [
    {
      name: 'Unit Tests - Components',
      command: `npx jest --config=jest.config.meal-planning.js --testPathPattern="components.*test" ${verboseMode ? '--verbose' : ''} ${updateSnapshots ? '--updateSnapshot' : ''}`,
      skip: false,
    },
    {
      name: 'Unit Tests - Store',
      command: `npx jest --config=jest.config.meal-planning.js --testPathPattern="store.*test" ${verboseMode ? '--verbose' : ''} ${updateSnapshots ? '--updateSnapshot' : ''}`,
      skip: false,
    },
    {
      name: 'Unit Tests - Hooks',
      command: `npx jest --config=jest.config.meal-planning.js --testPathPattern="hooks.*test" ${verboseMode ? '--verbose' : ''} ${updateSnapshots ? '--updateSnapshot' : ''}`,
      skip: false,
    },
    {
      name: 'Unit Tests - API Routes',
      command: `npx jest --config=jest.config.meal-planning.js --testPathPattern="api.*test" ${verboseMode ? '--verbose' : ''} ${updateSnapshots ? '--updateSnapshot' : ''}`,
      skip: false,
    },
    {
      name: 'Integration Tests',
      command: `npx jest --config=jest.config.meal-planning.js --testPathPattern="integration.*test" ${verboseMode ? '--verbose' : ''} ${updateSnapshots ? '--updateSnapshot' : ''}`,
      skip: quickMode,
    },
    {
      name: 'End-to-End Tests',
      command: `npx playwright test e2e/meal-planning/ ${verboseMode ? '--reporter=list' : ''}`,
      skip: !e2eMode || quickMode,
    },
  ];

  // Add coverage to all Jest commands if requested
  if (coverageMode && !watchMode) {
    testConfigs.forEach(config => {
      if (config.command.includes('jest')) {
        config.command += ' --coverage --coverageDirectory=coverage/meal-planning';
      }
    });
  }

  // Add watch mode if requested
  if (watchMode) {
    testConfigs.forEach(config => {
      if (config.command.includes('jest')) {
        config.command += ' --watch';
      }
    });
    log(`${COLORS.YELLOW}Running in watch mode - press 'q' to quit${COLORS.RESET}`);
  }

  // Run tests
  for (const config of testConfigs) {
    if (config.skip) {
      log(`${COLORS.YELLOW}⏭ Skipping: ${config.name}${COLORS.RESET}`);
      continue;
    }

    const testStartTime = Date.now();
    const success = runCommand(config.command, config.name);
    const duration = `${((Date.now() - testStartTime) / 1000).toFixed(2)}s`;

    testResults.push({
      name: config.name,
      command: config.command,
      success,
      duration,
      error: success ? null : 'Test execution failed',
    });

    if (!success && !watchMode) {
      log(`${COLORS.RED}Test suite failed. Stopping execution.${COLORS.RESET}`);
      break;
    }
  }

  // Generate reports (skip in watch mode)
  if (!watchMode) {
    const totalDuration = `${((Date.now() - startTime) / 1000).toFixed(2)}s`;
    const passedTests = testResults.filter(r => r.success).length;
    const totalTests = testResults.length;

    log(`\n${COLORS.BOLD}📊 Test Summary${COLORS.RESET}`);
    log(`${COLORS.CYAN}Total Duration: ${totalDuration}${COLORS.RESET}`);
    log(`${COLORS.GREEN}Passed: ${passedTests}/${totalTests}${COLORS.RESET}`);

    if (passedTests === totalTests) {
      log(`${COLORS.BOLD}${COLORS.GREEN}🎉 All tests passed!${COLORS.RESET}`);
    } else {
      log(`${COLORS.BOLD}${COLORS.RED}❌ Some tests failed${COLORS.RESET}`);
    }

    generateTestReport(testResults);

    // Show coverage information
    if (coverageMode) {
      log(`\n${COLORS.BOLD}📈 Coverage Report${COLORS.RESET}`);
      log(`${COLORS.CYAN}View detailed coverage: open coverage/meal-planning/lcov-report/index.html${COLORS.RESET}`);
      
      if (checkFileExists('coverage/meal-planning/coverage-summary.json')) {
        try {
          const coverageSummary = JSON.parse(
            fs.readFileSync('coverage/meal-planning/coverage-summary.json', 'utf8')
          );
          
          const total = coverageSummary.total;
          log(`${COLORS.YELLOW}Lines: ${total.lines.pct}%${COLORS.RESET}`);
          log(`${COLORS.YELLOW}Functions: ${total.functions.pct}%${COLORS.RESET}`);
          log(`${COLORS.YELLOW}Branches: ${total.branches.pct}%${COLORS.RESET}`);
          log(`${COLORS.YELLOW}Statements: ${total.statements.pct}%${COLORS.RESET}`);
        } catch (error) {
          log(`${COLORS.RED}Could not read coverage summary${COLORS.RESET}`);
        }
      }
    }

    // Exit with appropriate code
    process.exit(passedTests === totalTests ? 0 : 1);
  }
};

// Handle process interruption
process.on('SIGINT', () => {
  log(`\n${COLORS.YELLOW}Test execution interrupted${COLORS.RESET}`);
  process.exit(1);
});

// Run the main function
main().catch(error => {
  log(`${COLORS.RED}Unexpected error: ${error.message}${COLORS.RESET}`);
  console.error(error);
  process.exit(1);
});