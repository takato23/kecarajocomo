import { renderHook, act } from '@testing-library/react';
import { useGeminiMealPlanner } from '../useGeminiMealPlanner';
import { useMealPlanningStore } from '../../store/useMealPlanningStore';
import { geminiPlannerService } from '@/lib/services/geminiPlannerService';
import { toast } from 'sonner';
import type { UserPreferences, PlanningConstraints } from '@/lib/types/mealPlanning';
import { createMockUserPreferences, createMockWeekPlan } from '@/tests/utils/meal-planning-test-utils';

// Mock dependencies
jest.mock('../../store/useMealPlanningStore');
jest.mock('@/lib/services/geminiPlannerService');
jest.mock('sonner');
jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
  },
}));

describe('useGeminiMealPlanner', () => {
  const mockStore = {
    currentWeekPlan: null,
    userPreferences: createMockUserPreferences(),
    setCurrentWeekPlan: jest.fn(),
    loadWeekPlan: jest.fn(),
    saveWeekPlan: jest.fn(),
  };

  const mockGeminiResponse = {
    success: true,
    plan: {
      id: 'ai-plan-123',
      userId: 'test-user-id',
      weekPlan: createMockWeekPlan({
        id: 'ai-week-123',
        slots: [
          {
            id: 'slot-1',
            dayOfWeek: 1,
            mealType: 'almuerzo',
            date: '2024-01-15',
            servings: 2,
            recipeId: 'ai-recipe-1',
            recipe: {
              id: 'ai-recipe-1',
              name: 'AI Generated Recipe',
              description: 'Generated by AI',
              isAiGenerated: true,
            },
            isLocked: false,
            isCompleted: false,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          },
        ],
      }),
      shoppingList: {
        id: 'shopping-123',
        items: [],
        categories: [],
        estimatedTotal: 50.0,
      },
      nutritionSummary: {
        daily: { calories: 2000, protein: 100, carbs: 250, fat: 70 },
        weekly: { calories: 14000, protein: 700, carbs: 1750, fat: 490 },
      },
    },
    insights: {
      seasonalRecommendations: ['Use winter vegetables'],
      budgetOptimizations: ['Buy in bulk'],
      nutritionalBalance: ['Good protein distribution'],
    },
    metadata: {
      confidenceScore: 0.92,
      processingTime: '3.2s',
      optimizationLevel: 'high',
      recipesGenerated: 5,
      averageComplexity: 'medium',
    },
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (useMealPlanningStore as jest.Mock).mockReturnValue(mockStore);
    (geminiPlannerService.generateHolisticPlan as jest.Mock).mockResolvedValue(mockGeminiResponse);
  });

  describe('generateWeeklyPlan', () => {
    it('should generate weekly plan with default constraints', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      expect(geminiPlannerService.generateHolisticPlan).toHaveBeenCalledWith(
        mockStore.userPreferences,
        expect.objectContaining({
          startDate: new Date(weekPlan.startDate),
          endDate: new Date(weekPlan.endDate),
          availableTime: 60,
          includeLeftovers: true,
          excludeRecipeIds: [],
        }),
        expect.objectContaining({
          useHolisticAnalysis: true,
          includeExternalFactors: true,
          optimizeResources: true,
          enableLearning: true,
          analysisDepth: 'comprehensive',
        })
      );

      expect(result.current.lastGeneratedPlan).toEqual(mockGeminiResponse.plan);
      expect(result.current.confidence).toBe(0.92);
      expect(result.current.isGenerating).toBe(false);
    });

    it('should generate plan with custom constraints', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const customConstraints: Partial<PlanningConstraints> = {
        availableTime: 30,
        includeLeftovers: false,
        excludeRecipeIds: ['recipe-1', 'recipe-2'],
      };

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan(customConstraints);
      });

      expect(geminiPlannerService.generateHolisticPlan).toHaveBeenCalledWith(
        mockStore.userPreferences,
        expect.objectContaining({
          availableTime: 30,
          includeLeftovers: false,
          excludeRecipeIds: ['recipe-1', 'recipe-2'],
        }),
        expect.any(Object)
      );
    });

    it('should handle generation errors', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const errorResponse = {
        success: false,
        error: 'AI service unavailable',
      };

      (geminiPlannerService.generateHolisticPlan as jest.Mock).mockResolvedValue(errorResponse);

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      expect(toast.error).toHaveBeenCalledWith('Error generating meal plan: AI service unavailable');
      expect(result.current.lastGeneratedPlan).toBeNull();
      expect(result.current.isGenerating).toBe(false);
    });

    it('should handle network errors', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const networkError = new Error('Network error');
      (geminiPlannerService.generateHolisticPlan as jest.Mock).mockRejectedValue(networkError);

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      expect(toast.error).toHaveBeenCalledWith('Error generating meal plan: Network error');
      expect(result.current.lastGeneratedPlan).toBeNull();
      expect(result.current.isGenerating).toBe(false);
    });

    it('should not generate if no current week plan', async () => {
      mockStore.currentWeekPlan = null;

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      expect(geminiPlannerService.generateHolisticPlan).not.toHaveBeenCalled();
      expect(toast.error).toHaveBeenCalledWith('No current week plan available');
    });

    it('should not generate if user preferences are missing', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;
      mockStore.userPreferences = null;

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      expect(geminiPlannerService.generateHolisticPlan).not.toHaveBeenCalled();
      expect(toast.error).toHaveBeenCalledWith('User preferences not available');
    });

    it('should set loading state during generation', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      let resolveGeneration: (value: any) => void;
      const generationPromise = new Promise(resolve => {
        resolveGeneration = resolve;
      });

      (geminiPlannerService.generateHolisticPlan as jest.Mock).mockReturnValue(generationPromise);

      const { result } = renderHook(() => useGeminiMealPlanner());

      // Start generation
      act(() => {
        result.current.generateWeeklyPlan();
      });

      // Should be loading
      expect(result.current.isGenerating).toBe(true);

      // Complete generation
      await act(async () => {
        resolveGeneration!(mockGeminiResponse);
        await generationPromise;
      });

      // Should no longer be loading
      expect(result.current.isGenerating).toBe(false);
    });

    it('should respect locked slots in constraints', async () => {
      const weekPlan = createMockWeekPlan({
        slots: [
          {
            id: 'locked-slot',
            dayOfWeek: 1,
            mealType: 'almuerzo',
            date: '2024-01-15',
            servings: 2,
            recipeId: 'locked-recipe',
            isLocked: true,
            isCompleted: false,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          },
          {
            id: 'unlocked-slot',
            dayOfWeek: 2,
            mealType: 'cena',
            date: '2024-01-16',
            servings: 2,
            isLocked: false,
            isCompleted: false,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          },
        ],
      });
      mockStore.currentWeekPlan = weekPlan;

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      const calledConstraints = (geminiPlannerService.generateHolisticPlan as jest.Mock).mock.calls[0][1];
      expect(calledConstraints.lockedSlots).toEqual(['locked-slot']);
    });
  });

  describe('applyGeneratedPlan', () => {
    it('should apply generated plan to store', async () => {
      const { result } = renderHook(() => useGeminiMealPlanner());

      // First generate a plan
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      // Then apply it
      await act(async () => {
        await result.current.applyGeneratedPlan();
      });

      expect(mockStore.setCurrentWeekPlan).toHaveBeenCalledWith(mockGeminiResponse.plan.weekPlan);
      expect(mockStore.saveWeekPlan).toHaveBeenCalledWith(mockGeminiResponse.plan.weekPlan);
      expect(toast.success).toHaveBeenCalledWith('Meal plan applied successfully!');
    });

    it('should not apply if no generated plan available', async () => {
      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.applyGeneratedPlan();
      });

      expect(mockStore.setCurrentWeekPlan).not.toHaveBeenCalled();
      expect(mockStore.saveWeekPlan).not.toHaveBeenCalled();
      expect(toast.error).toHaveBeenCalledWith('No generated plan to apply');
    });

    it('should handle save errors when applying plan', async () => {
      const { result } = renderHook(() => useGeminiMealPlanner());

      // Generate a plan first
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      // Mock save error
      const saveError = new Error('Save failed');
      mockStore.saveWeekPlan.mockRejectedValue(saveError);

      await act(async () => {
        await result.current.applyGeneratedPlan();
      });

      expect(mockStore.setCurrentWeekPlan).toHaveBeenCalledWith(mockGeminiResponse.plan.weekPlan);
      expect(toast.error).toHaveBeenCalledWith('Error applying meal plan: Save failed');
    });
  });

  describe('regenerateSpecificMeal', () => {
    it('should regenerate a specific meal', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const regeneratedRecipe = {
        id: 'regenerated-recipe',
        name: 'Regenerated Recipe',
        description: 'A newly generated recipe',
        isAiGenerated: true,
      };

      (geminiPlannerService.generateSpecificMeal as jest.Mock) = jest.fn().mockResolvedValue({
        success: true,
        recipe: regeneratedRecipe,
        metadata: { confidenceScore: 0.88 },
      });

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.regenerateSpecificMeal('slot-1', 'almuerzo', {
          excludeIngredients: ['nuts'],
          maxCookingTime: 30,
        });
      });

      expect(geminiPlannerService.generateSpecificMeal).toHaveBeenCalledWith(
        'slot-1',
        'almuerzo',
        expect.objectContaining({
          excludeIngredients: ['nuts'],
          maxCookingTime: 30,
        }),
        mockStore.userPreferences
      );
    });
  });

  describe('optimizeDailyNutrition', () => {
    it('should optimize nutrition for a specific day', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const optimizedDay = {
        success: true,
        optimizedMeals: [
          {
            mealType: 'almuerzo',
            recipe: {
              id: 'optimized-recipe',
              name: 'Optimized Recipe',
              nutrition: { calories: 400, protein: 30, carbs: 40, fat: 15 },
            },
          },
        ],
        nutritionGoals: {
          targetCalories: 2000,
          targetProtein: 100,
          targetCarbs: 250,
          targetFat: 70,
        },
        metadata: { improvementScore: 0.15 },
      };

      (geminiPlannerService.optimizeDailyNutrition as jest.Mock) = jest.fn().mockResolvedValue(optimizedDay);

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.optimizeDailyNutrition(1, {
          targetCalories: 1800,
          targetProtein: 120,
        });
      });

      expect(geminiPlannerService.optimizeDailyNutrition).toHaveBeenCalledWith(
        1,
        weekPlan,
        expect.objectContaining({
          targetCalories: 1800,
          targetProtein: 120,
        }),
        mockStore.userPreferences
      );
    });
  });

  describe('Edge Cases and Error Handling', () => {
    it('should handle concurrent generation requests', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const { result } = renderHook(() => useGeminiMealPlanner());

      // Start multiple generation requests
      const promises = [
        act(async () => await result.current.generateWeeklyPlan()),
        act(async () => await result.current.generateWeeklyPlan()),
        act(async () => await result.current.generateWeeklyPlan()),
      ];

      await Promise.all(promises);

      // Should only call the service once (debounced or prevented)
      expect(geminiPlannerService.generateHolisticPlan).toHaveBeenCalledTimes(1);
    });

    it('should handle malformed API responses', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const malformedResponse = {
        success: true,
        plan: null, // Invalid - plan should be an object
      };

      (geminiPlannerService.generateHolisticPlan as jest.Mock).mockResolvedValue(malformedResponse);

      const { result } = renderHook(() => useGeminiMealPlanner());

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      expect(toast.error).toHaveBeenCalledWith('Error generating meal plan: Invalid response format');
      expect(result.current.lastGeneratedPlan).toBeNull();
    });

    it('should handle very large week plans', async () => {
      const largeWeekPlan = createMockWeekPlan({
        slots: Array.from({ length: 100 }, (_, i) => ({
          id: `slot-${i}`,
          dayOfWeek: i % 7,
          mealType: ['desayuno', 'almuerzo', 'merienda', 'cena'][i % 4],
          date: '2024-01-15',
          servings: 2,
          isLocked: false,
          isCompleted: false,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        })),
      });
      mockStore.currentWeekPlan = largeWeekPlan;

      const { result } = renderHook(() => useGeminiMealPlanner());

      const startTime = Date.now();
      await act(async () => {
        await result.current.generateWeeklyPlan();
      });
      const endTime = Date.now();

      // Should complete within reasonable time even with large data
      expect(endTime - startTime).toBeLessThan(5000);
      expect(geminiPlannerService.generateHolisticPlan).toHaveBeenCalled();
    });

    it('should clean up state on unmount', () => {
      const { unmount } = renderHook(() => useGeminiMealPlanner());

      // Start a generation
      act(() => {
        const weekPlan = createMockWeekPlan();
        mockStore.currentWeekPlan = weekPlan;
      });

      // Unmount should not cause errors
      expect(() => unmount()).not.toThrow();
    });
  });

  describe('Performance and Optimization', () => {
    it('should cache generation results', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const { result } = renderHook(() => useGeminiMealPlanner());

      // Generate plan twice with same parameters
      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      await act(async () => {
        await result.current.generateWeeklyPlan();
      });

      // Should potentially use cached result (depending on implementation)
      // This test would need to be adjusted based on actual caching strategy
      expect(geminiPlannerService.generateHolisticPlan).toHaveBeenCalledTimes(2);
    });

    it('should handle rapid successive calls', async () => {
      const weekPlan = createMockWeekPlan();
      mockStore.currentWeekPlan = weekPlan;

      const { result } = renderHook(() => useGeminiMealPlanner());

      // Make rapid successive calls
      const rapidCalls = Array.from({ length: 10 }, () =>
        act(async () => await result.current.generateWeeklyPlan())
      );

      await Promise.all(rapidCalls);

      // Should handle gracefully without overwhelming the service
      expect(result.current.isGenerating).toBe(false);
    });
  });
});